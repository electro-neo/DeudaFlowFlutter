Fecha: 2025-07-19

Errores encontrados y soluciones aplicadas en la sesión:

1. Error: Al presionar el botón "Movimientos" en la barra inferior, los filtros de cliente y tipo no se limpiaban correctamente o no se reflejaban en la UI.
   - Solución: Se modificó el método _onTab en MainScaffold para que use filterProvider.setClientId(null) y filterProvider.setType(null), que es el valor correcto para mostrar "Todos" en los dropdowns.

2. Error: Al limpiar los filtros desde la barra inferior, la pantalla de movimientos no actualizaba visualmente los dropdowns.
   - Solución: Se refactorizó TransactionsScreen para que los dropdowns de cliente y tipo usen SIEMPRE el valor del provider global (TransactionFilterProvider) y no variables locales. Así, cualquier cambio en el filtro se refleja automáticamente en la UI.

3. Error: Al aplicar la refactorización, quedaron referencias a variables locales (_selectedClientId, _selectedType) que ya no existían, causando errores de compilación.
   - Solución: Se eliminaron todas las referencias a esas variables y se ajustó la lógica para depender únicamente del provider.

4. Error: Al eliminar una transacción con swipe (Dismissible), Flutter mostraba el error "A dismissed Dismissible widget is still part of the tree" y la transacción no desaparecía de la UI inmediatamente.
   - Solución: Se corrigió el handler de onDismissed para eliminar la transacción de la lista visible en la UI usando setState en el mismo momento del swipe, cumpliendo el patrón recomendado por Flutter. El estado "pendiente por eliminar" ahora se muestra como feedback visual (snackbar/banner), y la sincronización/eliminación real ocurre en segundo plano con delay. Así se evita el error y la experiencia es fluida.

5. Error: Al compartir o guardar un recibo PDF de un solo cliente, el archivo se generaba con el nombre genérico "Recibo General de Clientes.pdf" en vez de personalizarse con el nombre del cliente.
   - Solución: Se ajustó la lógica de generación y guardado del PDF para que, si es un solo cliente, el archivo se llame "Recibo de Cliente (Nombre_del_cliente).pdf" (sanitizando el nombre para evitar caracteres inválidos). Si son varios clientes, se mantiene el nombre "Recibo General de Clientes.pdf".


6. Error: El botón "Ver movimientos" en el modal de detalles del cliente no cambiaba correctamente la pestaña ni aplicaba el filtro de cliente, ya que solo actualizaba el provider y no el estado local de la UI.
   - Solución: Se centralizó la lógica de cambio de pestaña y filtrado en MainScaffold, exponiendo un método público que puede ser llamado desde el modal o desde cualquier parte de la app. Ahora, al pulsar "Ver movimientos", se actualiza tanto el provider como el estado local, garantizando que la UI y los filtros estén sincronizados.

Resultado: Ahora los filtros de la pantalla de movimientos están 100% sincronizados con el provider global y cualquier cambio (desde la barra inferior, modal, etc.) se refleja correctamente en la UI. Además, el swipe para eliminar transacciones funciona sin errores visuales, la transacción desaparece de inmediato y la sincronización en background se mantiene. Por último, el nombre del archivo PDF es claro y personalizado según el caso, facilitando la identificación y el envío correcto del recibo.


7. Mejora: El buscador de transacciones ahora se limpia correctamente tanto la variable interna como el texto visible del campo de búsqueda al cambiar de pantalla, recargar la pestaña de movimientos o presionar el botón "Movimientos" en la barra inferior.
   - Solución: Se implementó el método resetSearchState en TransactionsScreen, que limpia tanto la variable interna como el texto del TextField usando un TextEditingController. Este método se llama desde MainScaffold usando un GlobalKey, asegurando que el buscador se limpie visual y lógicamente en todos los flujos relevantes.
   - Resultado: El usuario siempre ve el campo de búsqueda vacío y sin foco al cambiar de pestaña o recargar movimientos, evitando confusiones y mejorando la experiencia de usuario.


8. Error: El login con Google en Android se cancelaba tras seleccionar la cuenta, mostrando el mensaje "Inicio de sesión cancelado por el usuario" incluso con internet activo. El flujo no llegaba a obtener el idToken ni a autenticar con Supabase.
   - Solución y pasos para resolverlo:
     1. Se verificó que el Client ID de tipo Web estuviera correctamente configurado en Supabase y en el código Dart.
     2. Se revisó que la URI de redirección fuera exactamente la de Supabase en Google Cloud Console y en Supabase.
     3. Se confirmó que la pantalla de consentimiento OAuth estuviera publicada y sin restricciones de usuario.
     4. Se habilitaron las APIs necesarias en Google Cloud Console: People API e Identity Toolkit API.
     5. Se generó el SHA-1 de depuración y de release de la app Android.
     6. Se creó un Client ID de tipo Android en Google Cloud Console, asociando el nombre de paquete y el SHA-1 de la app.
     7. Se dejó el Client ID de tipo Web en Supabase y en el código, y el Client ID de tipo Android solo en Google Cloud Console.
     8. Se probó el login nuevamente y el flujo funcionó correctamente: se obtuvo el idToken, se autenticó con Supabase y se navegó al dashboard.
   - Resultado: El login con Google en Android funciona correctamente, el flujo OAuth es válido y la experiencia de usuario es fluida.

